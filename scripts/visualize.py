#!/usr/bin/env python3
"""
Market Maker Trade Visualization Suite

Generates 6 multi-panel analysis plots from wallet trade data collected
via the Polymarket data API. Each plot is a 2x2 (or 3x2) panel figure
examining a different facet of market-maker execution behavior.

Plots generated by this script (Tier A):
    01. Inventory trajectories  — UP vs DN accumulation, imbalance, pace
    02. Pair cost and P&L       — cost distribution, P&L curve, cost vs volume
    03. Fill characteristics    — size distribution, fill rate, timing, spread
    04. Regime sensitivity      — pair cost and win rate by trending/ranging
    05. Example windows         — 6 fill-by-fill window traces (2 per regime)
    06. Endgame behavior        — fill rate, heavy-side ratio, last-fill timing

Plots 07-18 are generated by l2_analysis.py, fingerprint_ladder.py, and the
synthesis pipeline (see scripts/ directory for those modules).

Data requirements:
    Wallet fill history only (JSON from Polymarket data API). No external
    price log is needed; regime classification and price analysis are derived
    from the outcome prices embedded in each fill record.

Environment variables:
    TRADES_FILE  Path to trades JSON (default: "data/trades.json")
    PLOT_DIR     Output directory for PNGs (default: "figures")

Usage:
    export TRADES_FILE="data/trades.json"
    python visualize.py
"""

import json
import os
from collections import defaultdict
from statistics import mean, median
import matplotlib
matplotlib.use('Agg')
import matplotlib.pyplot as plt
import numpy as np

# ---------------------------------------------------------------------------
# Configuration
# ---------------------------------------------------------------------------

TRADES_FILE = os.environ.get("TRADES_FILE", "data/trades.json")
PLOT_DIR = os.environ.get("PLOT_DIR", "figures")
DPI = 150


# ---------------------------------------------------------------------------
# Data loading & window computation
# ---------------------------------------------------------------------------

def load_trades():
    """Load trades JSON and group by window (slug)."""
    print(f"Loading trades from {TRADES_FILE} ...")
    with open(TRADES_FILE) as fh:
        raw = json.load(fh)

    by_window = defaultdict(list)
    for t in raw:
        by_window[t["slug"]].append({
            "ts": t["timestamp"],
            "price": t["price"],
            "size": t["size"],
            "side": t["side"],            # BUY / SELL
            "outcome": t["outcome"],      # Up / Down
            "usdc": t["usdcSize"],
        })

    # Sort each window chronologically
    for slug in by_window:
        by_window[slug].sort(key=lambda x: x["ts"])

    print(f"  {len(raw):,} fills across {len(by_window):,} windows")
    return dict(by_window)


def compute_window_stats(trades):
    """Compute core metrics for a single window's trade list.

    Returns dict with keys: up_shares, dn_shares, up_cost, dn_cost,
    pair_cost, pnl, duration, regime, final_imbalance.
    Returns None if window lacks fills on both sides.
    """
    up_shares, dn_shares = 0.0, 0.0
    up_cost, dn_cost = 0.0, 0.0

    for t in trades:
        outcome = t["outcome"].lower()
        if outcome == "up":
            up_shares += t["size"]
            up_cost += t["size"] * t["price"]
        else:
            dn_shares += t["size"]
            dn_cost += t["size"] * t["price"]

    if up_shares == 0 or dn_shares == 0:
        return None

    mean_up = up_cost / up_shares
    mean_dn = dn_cost / dn_shares
    pair_cost = mean_up + mean_dn
    paired = min(up_shares, dn_shares)
    pnl = (1.0 - pair_cost) * paired if pair_cost < 1.0 else -(pair_cost - 1.0) * paired

    total = up_shares + dn_shares
    final_imbalance = abs(up_shares - dn_shares) / total

    # Regime from first-to-last fill outcome prices
    first_up_price = next((t["price"] for t in trades if t["outcome"].lower() == "up"), None)
    last_up_price = next((t["price"] for t in reversed(trades) if t["outcome"].lower() == "up"), None)
    if first_up_price is not None and last_up_price is not None:
        move = last_up_price - first_up_price
    else:
        move = 0.0

    if abs(move) < 0.05:
        regime = "Ranging"
    elif move > 0:
        regime = "Trending UP"
    else:
        regime = "Trending DN"

    duration = trades[-1]["ts"] - trades[0]["ts"] if len(trades) > 1 else 0

    return {
        "up_shares": up_shares,
        "dn_shares": dn_shares,
        "up_cost": up_cost,
        "dn_cost": dn_cost,
        "pair_cost": pair_cost,
        "pnl": pnl,
        "final_imbalance": final_imbalance,
        "regime": regime,
        "price_move": move,
        "duration": duration,
        "total_volume": total,
        "n_fills": len(trades),
    }


def build_all_stats(by_window):
    """Return list of (slug, stats) for windows with valid two-sided fills."""
    results = []
    for slug, trades in by_window.items():
        stats = compute_window_stats(trades)
        if stats is not None:
            results.append((slug, stats))
    results.sort(key=lambda x: by_window[x[0]][0]["ts"])
    return results


# ---------------------------------------------------------------------------
# Helpers
# ---------------------------------------------------------------------------

def _lifecycle_seconds(trades):
    """Return per-fill seconds into window (0 = first fill)."""
    t0 = trades[0]["ts"]
    return [t["ts"] - t0 for t in trades]


def _percentile(vals, p):
    """Simple percentile (nearest-rank)."""
    if not vals:
        return 0.0
    s = sorted(vals)
    idx = int(len(s) * p / 100.0)
    return s[min(idx, len(s) - 1)]


def _ensure_outdir():
    os.makedirs(PLOT_DIR, exist_ok=True)


# ---------------------------------------------------------------------------
# Plot 01: Inventory Trajectories
# ---------------------------------------------------------------------------

def plot_01_inventory_trajectories(by_window, all_stats, n_sample=120):
    """2x2: (a) UP vs DN cumulative, (b) imbalance band, (c) pace, (d) final imbalance hist."""
    print("\nPlot 01: Inventory trajectories ...")
    fig, axes = plt.subplots(2, 2, figsize=(16, 12))
    np.random.seed(42)

    slugs = [s for s, _ in all_stats]
    sample_slugs = list(np.random.choice(slugs, min(n_sample, len(slugs)), replace=False))

    # --- (a) Sampled UP vs DN cumulative shares ---
    ax = axes[0, 0]
    for slug in sample_slugs:
        trades = by_window[slug]
        secs = _lifecycle_seconds(trades)
        duration = secs[-1] if secs[-1] > 0 else 1
        up_cum, dn_cum = 0.0, 0.0
        xs, ys_up, ys_dn = [], [], []
        for i, t in enumerate(trades):
            if t["outcome"].lower() == "up":
                up_cum += t["size"]
            else:
                dn_cum += t["size"]
            xs.append(secs[i] / duration)
            ys_up.append(up_cum)
            ys_dn.append(dn_cum)
        total = up_cum + dn_cum
        if total > 0:
            ax.plot(xs, [u / total for u in ys_up], color="#3366cc", alpha=0.06, linewidth=0.5)
            ax.plot(xs, [d / total for d in ys_dn], color="#cc3333", alpha=0.06, linewidth=0.5)
    ax.axhline(0.5, color="gray", linestyle="--", alpha=0.4)
    ax.set_xlabel("Fraction of window elapsed")
    ax.set_ylabel("Cumulative shares (fraction of total)")
    ax.set_title(f"(a) UP (blue) vs DN (red) Trajectories  (n={len(sample_slugs)} windows)")
    ax.set_xlim(0, 1)
    ax.set_ylim(0, 1)

    # --- (b) Imbalance over lifecycle ---
    ax = axes[0, 1]
    imb_by_bucket = defaultdict(list)
    for slug in sample_slugs:
        trades = by_window[slug]
        secs = _lifecycle_seconds(trades)
        duration = secs[-1] if secs[-1] > 0 else 1
        up_cum, dn_cum = 0.0, 0.0
        for i, t in enumerate(trades):
            if t["outcome"].lower() == "up":
                up_cum += t["size"]
            else:
                dn_cum += t["size"]
            total = up_cum + dn_cum
            if total > 0:
                bucket = round((secs[i] / duration) * 20) / 20
                imb_by_bucket[bucket].append(abs(up_cum - dn_cum) / total)

    buckets = sorted(imb_by_bucket.keys())
    meds = [median(imb_by_bucket[b]) for b in buckets]
    p25 = [_percentile(imb_by_bucket[b], 25) for b in buckets]
    p75 = [_percentile(imb_by_bucket[b], 75) for b in buckets]
    ax.fill_between(buckets, p25, p75, alpha=0.25, color="steelblue", label="P25 - P75")
    ax.plot(buckets, meds, color="steelblue", linewidth=2, label="Median")
    ax.set_xlabel("Fraction of window elapsed")
    ax.set_ylabel("|UP - DN| / total")
    ax.set_title(f"(b) Imbalance Over Lifecycle  (n={len(sample_slugs)} windows)")
    ax.legend()
    ax.set_xlim(0, 1)

    # --- (c) Accumulation pace ---
    ax = axes[1, 0]
    pace_by_bucket = defaultdict(list)
    for slug in sample_slugs:
        trades = by_window[slug]
        secs = _lifecycle_seconds(trades)
        duration = secs[-1] if secs[-1] > 0 else 1
        cum = 0.0
        total_final = sum(t["size"] for t in trades)
        if total_final == 0:
            continue
        for i, t in enumerate(trades):
            cum += t["size"]
            bucket = round((secs[i] / duration) * 20) / 20
            pace_by_bucket[bucket].append(cum / total_final)

    buckets = sorted(pace_by_bucket.keys())
    meds = [median(pace_by_bucket[b]) for b in buckets]
    ax.plot(buckets, meds, color="green", linewidth=2, label="Median pace")
    ax.plot([0, 1], [0, 1], "k--", alpha=0.3, label="Linear reference")
    ax.set_xlabel("Fraction of window elapsed")
    ax.set_ylabel("Fraction of total volume")
    ax.set_title("(c) Accumulation Pace")
    ax.legend()
    ax.set_xlim(0, 1)
    ax.set_ylim(0, 1)

    # --- (d) Final imbalance distribution ---
    ax = axes[1, 1]
    final_imbs = [s["final_imbalance"] for _, s in all_stats]
    ax.hist(final_imbs, bins=50, color="steelblue", edgecolor="white", alpha=0.8)
    med_val = median(final_imbs)
    ax.axvline(med_val, color="red", linestyle="--", label=f"Median: {med_val:.1%}")
    ax.set_xlabel("Final imbalance (|UP - DN| / total)")
    ax.set_ylabel("Windows")
    ax.set_title(f"(d) Final Imbalance Distribution  (n={len(final_imbs)} windows)")
    ax.legend()

    plt.tight_layout()
    path = os.path.join(PLOT_DIR, "01_inventory_trajectories.png")
    plt.savefig(path, dpi=DPI)
    plt.close()
    print(f"  Saved {path}")


# ---------------------------------------------------------------------------
# Plot 02: Pair Cost and P&L
# ---------------------------------------------------------------------------

def plot_02_pair_cost_and_pnl(all_stats):
    """2x2: (a) cost distribution, (b) P&L distribution, (c) cost vs volume, (d) cumulative P&L."""
    print("\nPlot 02: Pair cost and P&L ...")
    fig, axes = plt.subplots(2, 2, figsize=(16, 12))

    costs = [s["pair_cost"] for _, s in all_stats]
    pnls = [s["pnl"] for _, s in all_stats]
    volumes = [s["total_volume"] for _, s in all_stats]

    # --- (a) Combined pair cost ---
    ax = axes[0, 0]
    ax.hist(costs, bins=80, range=(0.88, 1.12), color="steelblue", edgecolor="white", alpha=0.8)
    ax.axvline(1.0, color="red", linestyle="--", linewidth=2, label="$1.00 breakeven")
    med_c = median(costs)
    ax.axvline(med_c, color="black", linestyle="--", label=f"Median: ${med_c:.4f}")
    ax.set_xlabel("Combined pair cost (mean_UP + mean_DN)")
    ax.set_ylabel("Windows")
    ax.set_title(f"(a) Pair Cost Distribution  (n={len(costs)} windows)")
    ax.legend()

    # --- (b) P&L per window ---
    ax = axes[0, 1]
    clipped = [max(-200, min(200, p)) for p in pnls]
    ax.hist(clipped, bins=80, color="green", edgecolor="white", alpha=0.8)
    ax.axvline(0, color="red", linestyle="--", linewidth=2)
    med_p = median(pnls)
    ax.axvline(med_p, color="black", linestyle="--", label=f"Median: ${med_p:.2f}")
    ax.set_xlabel("Window P&L ($)")
    ax.set_ylabel("Windows")
    ax.set_title(f"(b) P&L Distribution  (n={len(pnls)} windows)")
    ax.legend()

    # --- (c) Cost vs volume ---
    ax = axes[1, 0]
    ax.scatter(volumes, costs, alpha=0.12, s=5, color="steelblue")
    ax.axhline(1.0, color="red", linestyle="--", alpha=0.5)
    ax.set_xlabel("Total shares traded")
    ax.set_ylabel("Combined pair cost")
    ax.set_title("(c) Pair Cost vs Window Volume")
    ax.set_ylim(0.88, 1.12)

    # --- (d) Cumulative P&L ---
    ax = axes[1, 1]
    cum_pnl = np.cumsum(pnls)
    ax.plot(cum_pnl, color="green", linewidth=1)
    ax.fill_between(range(len(cum_pnl)), cum_pnl, alpha=0.15, color="green")
    ax.axhline(0, color="gray", linestyle="--")
    ax.set_xlabel("Window (chronological)")
    ax.set_ylabel("Cumulative P&L ($)")
    ax.set_title(f"(d) Cumulative P&L  (n={len(pnls)} windows)")

    plt.tight_layout()
    path = os.path.join(PLOT_DIR, "02_pair_cost_and_pnl.png")
    plt.savefig(path, dpi=DPI)
    plt.close()
    print(f"  Saved {path}")


# ---------------------------------------------------------------------------
# Plot 03: Fill Characteristics
# ---------------------------------------------------------------------------

def plot_03_fill_characteristics(by_window):
    """2x2: (a) fill size, (b) fills/second, (c) inter-fill timing, (d) same-second spread."""
    print("\nPlot 03: Fill characteristics ...")
    fig, axes = plt.subplots(2, 2, figsize=(16, 12))

    all_sizes = []
    fills_per_sec = []
    inter_fill_gaps = []
    same_sec_spreads = []

    for slug, trades in by_window.items():
        # Group by integer timestamp for same-second analysis
        by_ts = defaultdict(list)
        for t in trades:
            all_sizes.append(t["size"])
            by_ts[int(t["ts"])].append(t)

        ts_keys = sorted(by_ts.keys())
        for ts in ts_keys:
            batch = by_ts[ts]
            fills_per_sec.append(len(batch))
            prices = [b["price"] for b in batch]
            if len(prices) > 1:
                same_sec_spreads.append(max(prices) - min(prices))

        for i in range(1, len(ts_keys)):
            gap = ts_keys[i] - ts_keys[i - 1]
            inter_fill_gaps.append(gap)

    # --- (a) Fill size ---
    ax = axes[0, 0]
    clipped = [min(s, 150) for s in all_sizes]
    ax.hist(clipped, bins=80, color="steelblue", edgecolor="white", alpha=0.8)
    med = median(all_sizes)
    ax.axvline(med, color="red", linestyle="--", label=f"Median: {med:.1f}")
    ax.set_xlabel("Fill size (shares)")
    ax.set_ylabel("Fills")
    ax.set_title(f"(a) Fill Size Distribution  (n={len(all_sizes):,} fills)")
    ax.legend()

    # --- (b) Fills per second ---
    ax = axes[0, 1]
    max_show = 20
    from collections import Counter
    counts = Counter(fills_per_sec)
    xs = sorted(k for k in counts if k <= max_show)
    ys = [counts[k] for k in xs]
    ax.bar(xs, ys, color="steelblue", edgecolor="white")
    ax.set_xlabel("Fills per second")
    ax.set_ylabel("Occurrences")
    med_fps = median(fills_per_sec)
    ax.set_title(f"(b) Fills Per Second  (median={med_fps:.0f}, mean={mean(fills_per_sec):.1f})")

    # --- (c) Inter-fill timing ---
    ax = axes[1, 0]
    if inter_fill_gaps:
        clipped = [min(g, 60) for g in inter_fill_gaps]
        ax.hist(clipped, bins=60, color="green", edgecolor="white", alpha=0.8)
        med_g = median(inter_fill_gaps)
        ax.axvline(med_g, color="red", linestyle="--", label=f"Median: {med_g:.0f}s")
        ax.set_xlabel("Seconds between fill events")
        ax.set_ylabel("Gaps")
        ax.set_title(f"(c) Inter-Fill Timing  (n={len(inter_fill_gaps):,})")
        ax.legend()

    # --- (d) Same-second price spread ---
    ax = axes[1, 1]
    if same_sec_spreads:
        clipped = [min(s * 100, 20) for s in same_sec_spreads]
        ax.hist(clipped, bins=50, color="tomato", edgecolor="white", alpha=0.8)
        med_sp = median(same_sec_spreads) * 100
        ax.axvline(med_sp, color="black", linestyle="--", label=f"Median: {med_sp:.2f}c")
        ax.set_xlabel("Price spread within same second (cents)")
        ax.set_ylabel("Batches")
        ax.set_title(f"(d) Same-Second Price Spread  (n={len(same_sec_spreads):,})")
        ax.legend()

    plt.tight_layout()
    path = os.path.join(PLOT_DIR, "03_fill_characteristics.png")
    plt.savefig(path, dpi=DPI)
    plt.close()
    print(f"  Saved {path}")


# ---------------------------------------------------------------------------
# Plot 04: Regime Sensitivity
# ---------------------------------------------------------------------------

def plot_04_regime_sensitivity(all_stats):
    """2x2: (a) pair cost by regime, (b) win rate by |move|, (c) P&L scatter, (d) imbalance by regime."""
    print("\nPlot 04: Regime sensitivity ...")
    fig, axes = plt.subplots(2, 2, figsize=(16, 12))

    by_regime = defaultdict(list)
    for _, s in all_stats:
        by_regime[s["regime"]].append(s)

    regime_order = ["Trending DN", "Ranging", "Trending UP"]
    regime_colors = ["#cc3333", "steelblue", "#33aa33"]

    # --- (a) Pair cost by regime ---
    ax = axes[0, 0]
    for i, regime in enumerate(regime_order):
        ws = by_regime.get(regime, [])
        if ws:
            bp = ax.boxplot(
                [[w["pair_cost"] for w in ws]], positions=[i],
                widths=0.6, patch_artist=True, showfliers=False,
            )
            bp["boxes"][0].set_facecolor(regime_colors[i])
            bp["boxes"][0].set_alpha(0.7)
    ax.set_xticks(range(len(regime_order)))
    ax.set_xticklabels([f"{r}\n(n={len(by_regime.get(r, []))})" for r in regime_order])
    ax.axhline(1.0, color="red", linestyle="--", alpha=0.5, label="Breakeven")
    ax.set_ylabel("Combined pair cost")
    ax.set_title("(a) Pair Cost by Regime")
    ax.legend()

    # --- (b) Win rate by absolute price move ---
    ax = axes[0, 1]
    move_buckets = defaultdict(list)
    for _, s in all_stats:
        bucket = round(abs(s["price_move"]) * 10) / 10
        bucket = min(bucket, 0.5)
        win = 1 if s["pnl"] > 0 else 0
        move_buckets[bucket].append(win)
    bk = sorted(move_buckets.keys())
    wrs = [mean(move_buckets[b]) * 100 for b in bk]
    ns = [len(move_buckets[b]) for b in bk]
    ax.bar(bk, wrs, width=0.08, color="steelblue", alpha=0.8)
    ax.axhline(50, color="gray", linestyle="--", alpha=0.5)
    ax.set_xlabel("Absolute price move (first to last fill)")
    ax.set_ylabel("Win rate (%)")
    ax.set_title(f"(b) Win Rate by |Price Move|  (n={len(all_stats)} windows)")

    # --- (c) P&L scatter by regime ---
    ax = axes[1, 0]
    for regime, color in zip(regime_order, regime_colors):
        ws = by_regime.get(regime, [])
        if ws:
            moves = [w["price_move"] for w in ws]
            pnls = [w["pnl"] for w in ws]
            ax.scatter(moves, pnls, c=color, alpha=0.12, s=5, label=regime)
    ax.axhline(0, color="gray", linestyle="--")
    ax.axvline(0, color="gray", linestyle="--")
    ax.set_xlabel("Price move (first-to-last fill)")
    ax.set_ylabel("Window P&L ($)")
    ax.set_title("(c) P&L vs Price Move by Regime")
    ax.legend(markerscale=4, fontsize=8)

    # --- (d) Final imbalance by regime ---
    ax = axes[1, 1]
    for i, regime in enumerate(regime_order):
        ws = by_regime.get(regime, [])
        if ws:
            bp = ax.boxplot(
                [[w["final_imbalance"] for w in ws]], positions=[i],
                widths=0.6, patch_artist=True, showfliers=False,
            )
            bp["boxes"][0].set_facecolor(regime_colors[i])
            bp["boxes"][0].set_alpha(0.7)
    ax.set_xticks(range(len(regime_order)))
    ax.set_xticklabels([f"{r}\n(n={len(by_regime.get(r, []))})" for r in regime_order])
    ax.set_ylabel("Final imbalance (|UP - DN| / total)")
    ax.set_title("(d) Final Imbalance by Regime")

    plt.tight_layout()
    path = os.path.join(PLOT_DIR, "04_regime_sensitivity.png")
    plt.savefig(path, dpi=DPI)
    plt.close()
    print(f"  Saved {path}")


# ---------------------------------------------------------------------------
# Plot 05: Example Windows
# ---------------------------------------------------------------------------

def plot_05_example_windows(by_window, all_stats):
    """3x2: 6 windows (2 ranging, 2 trending-up, 2 trending-down) with fill-by-fill traces."""
    print("\nPlot 05: Example windows ...")

    categorized = {"Ranging": [], "Trending UP": [], "Trending DN": []}
    for slug, s in all_stats:
        if s["n_fills"] >= 50:
            categorized[s["regime"]].append(slug)

    fig, axes = plt.subplots(3, 2, figsize=(18, 18))
    np.random.seed(99)

    row_idx = 0
    for regime in ["Ranging", "Trending UP", "Trending DN"]:
        slug_list = categorized[regime]
        if len(slug_list) < 2:
            row_idx += 1
            continue
        chosen = list(np.random.choice(slug_list, 2, replace=False))

        for col, slug in enumerate(chosen):
            ax = axes[row_idx, col]
            trades = by_window[slug]
            secs = _lifecycle_seconds(trades)

            up_cum, dn_cum = 0.0, 0.0
            xs, ys_up, ys_dn = [], [], []
            for i, t in enumerate(trades):
                if t["outcome"].lower() == "up":
                    up_cum += t["size"]
                else:
                    dn_cum += t["size"]
                xs.append(secs[i])
                ys_up.append(up_cum)
                ys_dn.append(dn_cum)

            ax.plot(xs, ys_up, color="#3366cc", linewidth=1.5, label="UP shares")
            ax.plot(xs, ys_dn, color="#cc3333", linewidth=1.5, label="DN shares")

            stats = compute_window_stats(trades)
            subtitle = (
                f"{regime}  |  cost=${stats['pair_cost']:.3f}  |  "
                f"P&L=${stats['pnl']:.0f}  |  {stats['n_fills']} fills"
            ) if stats else regime
            ax.set_title(subtitle, fontsize=10)
            ax.set_xlabel("Seconds into window")
            ax.set_ylabel("Cumulative shares")
            ax.legend(loc="upper left", fontsize=8)

        row_idx += 1

    plt.tight_layout()
    path = os.path.join(PLOT_DIR, "05_example_windows.png")
    plt.savefig(path, dpi=DPI)
    plt.close()
    print(f"  Saved {path}")


# ---------------------------------------------------------------------------
# Plot 06: Endgame Behavior
# ---------------------------------------------------------------------------

def plot_06_endgame_behavior(by_window, all_stats):
    """2x2: (a) fill rate buckets, (b) heavy-side ratio, (c) last-fill timing, (d) taker % final 2 min."""
    print("\nPlot 06: Endgame behavior ...")
    fig, axes = plt.subplots(2, 2, figsize=(16, 12))

    BUCKET_SEC = 30
    rate_by_bucket = defaultdict(list)     # bucket_idx -> fill counts per window
    heavy_ratio_by_bucket = defaultdict(list)
    last_fill_offsets = []                 # seconds before window end
    taker_final_pcts = []
    taker_rest_pcts = []

    valid_slugs = [slug for slug, _ in all_stats]

    for slug in valid_slugs:
        trades = by_window[slug]
        if len(trades) < 10:
            continue
        secs = _lifecycle_seconds(trades)
        duration = secs[-1]
        if duration < 60:
            continue

        # Last fill offset (seconds from end)
        last_fill_offsets.append(duration - secs[-2] if len(secs) > 1 else 0)

        # Bucket fill rates and heavy-side ratio
        n_buckets = max(1, int(duration / BUCKET_SEC))
        for b_idx in range(n_buckets):
            lo = b_idx * BUCKET_SEC
            hi = lo + BUCKET_SEC
            bucket_trades = [t for t, s in zip(trades, secs) if lo <= s < hi]
            rate_by_bucket[b_idx].append(len(bucket_trades))

            up_in_bucket = sum(t["size"] for t in bucket_trades if t["outcome"].lower() == "up")
            dn_in_bucket = sum(t["size"] for t in bucket_trades if t["outcome"].lower() == "down")
            total_in_bucket = up_in_bucket + dn_in_bucket
            if total_in_bucket > 0:
                heavy = max(up_in_bucket, dn_in_bucket)
                heavy_ratio_by_bucket[b_idx].append(heavy / total_in_bucket)

        # Taker heuristic: classify fills above running average as "aggressive"
        running_prices = []
        final_cutoff = duration - 120  # last 2 minutes
        agg_final, total_final = 0, 0
        agg_rest, total_rest = 0, 0

        for t, s in zip(trades, secs):
            running_prices.append(t["price"])
            running_avg = mean(running_prices)
            is_aggressive = t["price"] > running_avg

            if s >= final_cutoff:
                total_final += 1
                if is_aggressive:
                    agg_final += 1
            else:
                total_rest += 1
                if is_aggressive:
                    agg_rest += 1

        if total_final > 0:
            taker_final_pcts.append(agg_final / total_final * 100)
        if total_rest > 0:
            taker_rest_pcts.append(agg_rest / total_rest * 100)

    # --- (a) Fill rate in 30-second buckets ---
    ax = axes[0, 0]
    common_buckets = sorted(b for b in rate_by_bucket if len(rate_by_bucket[b]) >= 20)
    if common_buckets:
        meds = [median(rate_by_bucket[b]) for b in common_buckets]
        ax.bar(
            [b * BUCKET_SEC for b in common_buckets], meds,
            width=BUCKET_SEC * 0.8, color="steelblue", edgecolor="white", alpha=0.8,
        )
    ax.set_xlabel("Seconds into window")
    ax.set_ylabel("Median fills per 30s bucket")
    ax.set_title(f"(a) Fill Rate Over Lifecycle  (n={len(valid_slugs)} windows)")

    # --- (b) Heavy-side fill ratio ---
    ax = axes[0, 1]
    common_buckets = sorted(b for b in heavy_ratio_by_bucket if len(heavy_ratio_by_bucket[b]) >= 20)
    if common_buckets:
        meds = [median(heavy_ratio_by_bucket[b]) for b in common_buckets]
        ax.plot(
            [b * BUCKET_SEC for b in common_buckets], meds,
            color="tomato", linewidth=2, marker="o", markersize=3,
        )
    ax.axhline(0.5, color="gray", linestyle="--", alpha=0.4, label="50% (balanced)")
    ax.set_xlabel("Seconds into window")
    ax.set_ylabel("Heavy-side share ratio")
    ax.set_title("(b) Heavy vs Light Side Over Lifecycle")
    ax.legend()

    # --- (c) Last fill timing ---
    ax = axes[1, 0]
    if last_fill_offsets:
        clipped = [min(o, 120) for o in last_fill_offsets]
        ax.hist(clipped, bins=40, color="purple", edgecolor="white", alpha=0.8)
        med_lf = median(last_fill_offsets)
        ax.axvline(med_lf, color="red", linestyle="--", label=f"Median: {med_lf:.0f}s")
        ax.set_xlabel("Seconds before window end")
        ax.set_ylabel("Windows")
        ax.set_title(f"(c) Last Fill Timing  (n={len(last_fill_offsets)} windows)")
        ax.legend()

    # --- (d) Taker % final 2 minutes vs rest ---
    ax = axes[1, 1]
    labels = ["Rest of window", "Final 2 minutes"]
    data = [taker_rest_pcts, taker_final_pcts]
    colors = ["steelblue", "tomato"]
    positions = [0, 1]
    for i, (vals, color) in enumerate(zip(data, colors)):
        if vals:
            bp = ax.boxplot(
                [vals], positions=[positions[i]], widths=0.5,
                patch_artist=True, showfliers=False,
            )
            bp["boxes"][0].set_facecolor(color)
            bp["boxes"][0].set_alpha(0.7)
    ax.set_xticks(positions)
    n_rest = len(taker_rest_pcts)
    n_final = len(taker_final_pcts)
    ax.set_xticklabels([f"Rest\n(n={n_rest})", f"Final 2 min\n(n={n_final})"])
    ax.set_ylabel("Aggressive-buy % (price > running avg)")
    ax.set_title("(d) Taker Heuristic: Final 2 Minutes vs Rest")

    plt.tight_layout()
    path = os.path.join(PLOT_DIR, "06_endgame_behavior.png")
    plt.savefig(path, dpi=DPI)
    plt.close()
    print(f"  Saved {path}")


# ---------------------------------------------------------------------------
# Main
# ---------------------------------------------------------------------------

def main():
    _ensure_outdir()
    by_window = load_trades()
    all_stats = build_all_stats(by_window)
    print(f"  {len(all_stats):,} windows with two-sided fills\n")

    plot_01_inventory_trajectories(by_window, all_stats)
    plot_02_pair_cost_and_pnl(all_stats)
    plot_03_fill_characteristics(by_window)
    plot_04_regime_sensitivity(all_stats)
    plot_05_example_windows(by_window, all_stats)
    plot_06_endgame_behavior(by_window, all_stats)

    print(f"\n{'=' * 60}")
    print(f"All 6 plots saved to {PLOT_DIR}/")
    print(f"{'=' * 60}")


if __name__ == "__main__":
    main()
