#!/usr/bin/env python3
"""
Market Maker Trade Visualization Suite

Generates 7 multi-panel analysis plots from wallet trade data:

    01. Inventory trajectories — UP vs DN cumulative shares, imbalance, pace
    02. Fill vs mid-price — edge distribution, crossing depth
    03. Batching patterns — fills/sec, price spread, inter-fill timing, sizes
    04. Regime analysis — pair cost and win rate by trending/ranging regime
    05. Pair cost & P&L — combined cost distribution, cumulative P&L
    06. Example windows — 6 detailed traces (2 ranging, 2 up, 2 down)
    07. Crossing behavior — aggression rate, win rate by aggression level

Plots 08-22 in the figures/ directory were generated by specialized
analysis scripts (analyze_*.py) in the source data pipeline.

Data requirements:
    - Wallet fill history (JSON from Polymarket data API)
    - Price log (CSV: timestamp, yes_price, no_price per market)

Usage:
    export TRADES_FILE="data/trades.json"
    export PRICE_LOG="data/price_log.csv"
    python visualize.py
"""

import json
import csv
import os
from collections import defaultdict, Counter
from datetime import datetime, timezone
from statistics import mean, median, stdev
from bisect import bisect_left
import matplotlib
matplotlib.use('Agg')
import matplotlib.pyplot as plt
import matplotlib.gridspec as gridspec
import numpy as np

OUTDIR = os.environ.get("PLOT_DIR", "figures")
os.makedirs(OUTDIR, exist_ok=True)


# ============================================================================
# DATA LOADING
# ============================================================================

def load_trades(path=None):
    path = path or os.environ.get("TRADES_FILE", "data/trades.json")
    print(f"Loading trades from {path}...")
    with open(path) as f:
        trades = json.load(f)
    by_window = defaultdict(list)
    for t in trades:
        side = t['outcome'].lower()
        by_window[t['slug']].append({
            'ts': t['timestamp'],
            'side': side,
            'price': t['price'],
            'size': t['size'],
            'usdc': t['usdcSize'],
        })
    for slug in by_window:
        by_window[slug].sort(key=lambda x: x['ts'])
    print(f"  {len(trades):,} trades across {len(by_window):,} windows")
    return dict(by_window)


def load_prices(path=None):
    path = path or os.environ.get("PRICE_LOG", "data/price_log.csv")
    print(f"Loading prices from {path}...")
    windows = defaultdict(lambda: {'ts': [], 'yes': [], 'no': []})
    with open(path) as f:
        reader = csv.DictReader(f)
        for row in reader:
            slug = row.get('market_id', '')
            if 'btc-updown-15m' not in slug:
                continue
            try:
                dt = datetime.fromisoformat(row['timestamp'])
                ts = dt.replace(tzinfo=timezone.utc).timestamp()
                yes = float(row['yes_price'])
                no = float(row['no_price'])
                windows[slug]['ts'].append(ts)
                windows[slug]['yes'].append(yes)
                windows[slug]['no'].append(no)
            except (ValueError, KeyError):
                continue

    result = {}
    for slug, data in windows.items():
        if len(data['ts']) < 10:
            continue
        indices = sorted(range(len(data['ts'])), key=lambda i: data['ts'][i])
        result[slug] = {
            'ts': [data['ts'][i] for i in indices],
            'yes': [data['yes'][i] for i in indices],
            'no': [data['no'][i] for i in indices],
        }
    print(f"  {len(result):,} windows with price data")
    return result


def get_price_at(prices, target_ts, max_diff=5.0):
    ts_list = prices['ts']
    idx = bisect_left(ts_list, target_ts)
    best_idx, best_diff = None, float('inf')
    for c in [idx - 1, idx]:
        if 0 <= c < len(ts_list):
            d = abs(ts_list[c] - target_ts)
            if d < best_diff:
                best_diff = d
                best_idx = c
    if best_idx is None or best_diff > max_diff:
        return None, None
    return prices['yes'][best_idx], prices['no'][best_idx]


def get_outcome(prices):
    if not prices['yes']:
        return None
    fy, fn = prices['yes'][-1], prices['no'][-1]
    if fy >= 0.95:
        return 'UP'
    elif fn >= 0.95:
        return 'DOWN'
    return None


# ============================================================================
# PLOT 1: INVENTORY TRAJECTORIES
# ============================================================================

def plot_inventory_trajectories(by_window, prices, n_sample=100):
    print("\nPlot 1: Inventory trajectories...")
    fig, axes = plt.subplots(2, 2, figsize=(16, 12))

    slugs = sorted(set(by_window.keys()) & set(prices.keys()))
    np.random.seed(42)
    sample = np.random.choice(slugs, min(n_sample, len(slugs)), replace=False)

    ax = axes[0, 0]
    for slug in sample:
        trades = by_window[slug]
        window_start = int(slug.split('-')[-1])
        up_cum, dn_cum, times = [], [], []
        up_total, dn_total = 0, 0
        for t in trades:
            if t['side'] == 'up':
                up_total += t['size']
            else:
                dn_total += t['size']
            pct = (t['ts'] - window_start) / 900.0
            up_cum.append(up_total)
            dn_cum.append(dn_total)
            times.append(pct)
        total = up_total + dn_total
        if total > 0:
            ax.plot(times, [u / total for u in up_cum], color='blue', alpha=0.08, linewidth=0.5)
            ax.plot(times, [d / total for d in dn_cum], color='red', alpha=0.08, linewidth=0.5)
    ax.axhline(0.5, color='gray', linestyle='--', alpha=0.5)
    ax.set_xlabel('% window elapsed')
    ax.set_ylabel('Cumulative shares (% of total)')
    ax.set_title(f'UP (blue) vs DN (red) Inventory Trajectories (n={len(sample)})')
    ax.set_xlim(0, 1)
    ax.set_ylim(0, 1)

    ax = axes[0, 1]
    imb_by_bucket = defaultdict(list)
    for slug in sample:
        trades = by_window[slug]
        window_start = int(slug.split('-')[-1])
        up_total, dn_total = 0, 0
        for t in trades:
            if t['side'] == 'up':
                up_total += t['size']
            else:
                dn_total += t['size']
            total = up_total + dn_total
            if total > 0:
                pct = (t['ts'] - window_start) / 900.0
                bucket = round(pct * 20) / 20
                imb = abs(up_total - dn_total) / total
                imb_by_bucket[bucket].append(imb)

    buckets_sorted = sorted(imb_by_bucket.keys())
    medians = [median(imb_by_bucket[b]) for b in buckets_sorted]
    p25 = [sorted(imb_by_bucket[b])[len(imb_by_bucket[b]) // 4] for b in buckets_sorted]
    p75 = [sorted(imb_by_bucket[b])[3 * len(imb_by_bucket[b]) // 4] for b in buckets_sorted]

    ax.fill_between(buckets_sorted, p25, p75, alpha=0.3, color='steelblue', label='P25-P75')
    ax.plot(buckets_sorted, medians, color='steelblue', linewidth=2, label='Median')
    ax.set_xlabel('% window elapsed')
    ax.set_ylabel('Position imbalance (|UP-DN|/total)')
    ax.set_title('Inventory Imbalance Over Window Lifecycle')
    ax.legend()
    ax.set_xlim(0, 1)

    ax = axes[1, 0]
    shares_by_bucket = defaultdict(list)
    for slug in sample:
        trades = by_window[slug]
        window_start = int(slug.split('-')[-1])
        cum = 0
        total_final = sum(t['size'] for t in trades)
        for t in trades:
            cum += t['size']
            pct = (t['ts'] - window_start) / 900.0
            bucket = round(pct * 20) / 20
            shares_by_bucket[bucket].append(cum / total_final if total_final > 0 else 0)

    buckets_sorted = sorted(shares_by_bucket.keys())
    medians = [median(shares_by_bucket[b]) for b in buckets_sorted]
    ax.plot(buckets_sorted, medians, color='green', linewidth=2)
    ax.plot([0, 1], [0, 1], 'k--', alpha=0.3, label='Linear pace')
    ax.set_xlabel('% window elapsed')
    ax.set_ylabel('% of total volume accumulated')
    ax.set_title('Volume Accumulation Pace')
    ax.legend()
    ax.set_xlim(0, 1)
    ax.set_ylim(0, 1)

    ax = axes[1, 1]
    final_imbs = []
    for slug in slugs:
        trades = by_window[slug]
        up_total = sum(t['size'] for t in trades if t['side'] == 'up')
        dn_total = sum(t['size'] for t in trades if t['side'] == 'down')
        total = up_total + dn_total
        if total > 0:
            final_imbs.append(abs(up_total - dn_total) / total)

    ax.hist(final_imbs, bins=50, color='steelblue', edgecolor='white', alpha=0.8)
    ax.axvline(median(final_imbs), color='red', linestyle='--', label=f'Median: {median(final_imbs):.1%}')
    ax.set_xlabel('Final imbalance (|UP-DN|/total)')
    ax.set_ylabel('# windows')
    ax.set_title(f'Final Inventory Imbalance at Resolution (n={len(final_imbs)})')
    ax.legend()

    plt.tight_layout()
    path = os.path.join(OUTDIR, '01_inventory_trajectories.png')
    plt.savefig(path, dpi=150)
    plt.close()
    print(f"  Saved: {path}")


# ============================================================================
# PLOT 2: FILL PRICE VS MID-PRICE
# ============================================================================

def plot_fill_vs_mid(by_window, prices):
    print("\nPlot 2: Fill price vs mid-price...")
    fig, axes = plt.subplots(2, 2, figsize=(16, 12))

    edges = []
    slugs = sorted(set(by_window.keys()) & set(prices.keys()))

    for slug in slugs:
        trades = by_window[slug]
        window_start = int(slug.split('-')[-1])
        up_sh, dn_sh = 0, 0
        for t in trades:
            yes_p, no_p = get_price_at(prices[slug], t['ts'])
            if yes_p is None:
                if t['side'] == 'up': up_sh += t['size']
                else: dn_sh += t['size']
                continue
            mid = yes_p if t['side'] == 'up' else no_p
            edge = mid - t['price']
            pct = (t['ts'] - window_start) / 900.0
            total = up_sh + dn_sh
            imb = abs(up_sh - dn_sh) / total if total > 0 else 0
            edges.append((edge, t['side'], pct, imb, t['size']))
            if t['side'] == 'up': up_sh += t['size']
            else: dn_sh += t['size']

    print(f"  {len(edges):,} fills with price data")
    edge_vals = [e[0] for e in edges]

    ax = axes[0, 0]
    clipped = [max(-0.10, min(0.10, e)) for e in edge_vals]
    ax.hist(clipped, bins=100, color='steelblue', edgecolor='white', alpha=0.8)
    ax.axvline(0, color='red', linestyle='--', linewidth=2, label='Mid price')
    pct_agg = sum(1 for e in edge_vals if e <= 0) / len(edge_vals) * 100
    ax.set_xlabel('Edge (mid - fill_price)')
    ax.set_ylabel('# fills')
    ax.set_title(f'Fill Price vs Mid: {pct_agg:.1f}% aggressive (edge <= 0)')
    ax.legend()

    ax = axes[0, 1]
    time_buckets = defaultdict(list)
    for edge, side, pct, imb, size in edges:
        bucket = round(pct * 10) / 10
        time_buckets[min(bucket, 1.0)].append(edge)
    buckets_sorted = sorted(time_buckets.keys())
    meds = [median(time_buckets[b]) * 100 for b in buckets_sorted]
    means = [mean(time_buckets[b]) * 100 for b in buckets_sorted]
    ax.bar(buckets_sorted, meds, width=0.08, color='steelblue', alpha=0.8, label='Median')
    ax.plot(buckets_sorted, means, 'ro-', markersize=4, label='Mean')
    ax.axhline(0, color='gray', linestyle='--')
    ax.set_xlabel('% window elapsed')
    ax.set_ylabel('Edge (cents)')
    ax.set_title('Edge Over Time (+ = passive, - = aggressive)')
    ax.legend()

    ax = axes[1, 0]
    imb_buckets = defaultdict(list)
    for edge, side, pct, imb, size in edges:
        bucket = round(imb * 20) / 20
        imb_buckets[min(bucket, 0.5)].append(edge)
    buckets_sorted = sorted(imb_buckets.keys())
    meds = [median(imb_buckets[b]) * 100 for b in buckets_sorted]
    ax.bar(buckets_sorted, meds, width=0.04, color='steelblue', alpha=0.8)
    ax.axhline(0, color='gray', linestyle='--')
    ax.set_xlabel('Position imbalance (|UP-DN|/total)')
    ax.set_ylabel('Median edge (cents)')
    ax.set_title('Edge vs Inventory Imbalance')

    ax = axes[1, 1]
    agg_edges = [-e * 100 for e in edge_vals if e < 0]
    if agg_edges:
        ax.hist(agg_edges, bins=80, range=(0, 10), color='tomato', edgecolor='white', alpha=0.8)
        ax.axvline(median(agg_edges), color='black', linestyle='--',
                   label=f'Median: {median(agg_edges):.2f}c')
        ax.axvline(mean(agg_edges), color='blue', linestyle='--',
                   label=f'Mean: {mean(agg_edges):.2f}c')
        ax.set_xlabel('Crossing depth (cents above mid)')
        ax.set_ylabel('# fills')
        ax.set_title(f'Crossing Depth ({len(agg_edges):,} aggressive fills)')
        ax.legend()

    plt.tight_layout()
    path = os.path.join(OUTDIR, '02_fill_vs_mid.png')
    plt.savefig(path, dpi=150)
    plt.close()
    print(f"  Saved: {path}")


# ============================================================================
# PLOT 3: BATCHING ANALYSIS
# ============================================================================

def plot_batching(by_window):
    print("\nPlot 3: Batching patterns...")
    fig, axes = plt.subplots(2, 2, figsize=(16, 12))

    fills_per_sec = []
    price_spreads = []
    inter_batch = []
    fill_sizes = []

    for slug, trades in by_window.items():
        by_ts = defaultdict(list)
        for t in trades:
            by_ts[t['ts']].append(t)

        unique_ts = sorted(by_ts.keys())
        for ts in unique_ts:
            batch = by_ts[ts]
            fills_per_sec.append(len(batch))
            prices_in_batch = [t['price'] for t in batch]
            if len(prices_in_batch) > 1:
                price_spreads.append(max(prices_in_batch) - min(prices_in_batch))
            for t in batch:
                fill_sizes.append(t['size'])

        for i in range(1, len(unique_ts)):
            inter_batch.append(unique_ts[i] - unique_ts[i - 1])

    ax = axes[0, 0]
    counts = Counter(fills_per_sec)
    x = sorted(counts.keys())[:20]
    y = [counts[k] for k in x]
    ax.bar(x, y, color='steelblue', edgecolor='white')
    ax.set_xlabel('Fills per second')
    ax.set_ylabel('Occurrences')
    ax.set_title(f'Fills Per Second (median={median(fills_per_sec)}, mean={mean(fills_per_sec):.1f})')

    ax = axes[0, 1]
    if price_spreads:
        clipped = [min(s * 100, 20) for s in price_spreads]
        ax.hist(clipped, bins=50, color='tomato', edgecolor='white', alpha=0.8)
        ax.axvline(median(price_spreads) * 100, color='black', linestyle='--',
                   label=f'Median: {median(price_spreads) * 100:.1f}c')
        ax.set_xlabel('Price spread within same second (cents)')
        ax.set_ylabel('# batches')
        ax.set_title('Price Spread Within Same-Second Fills')
        ax.legend()

    ax = axes[1, 0]
    if inter_batch:
        clipped = [min(t, 30) for t in inter_batch]
        ax.hist(clipped, bins=60, color='green', edgecolor='white', alpha=0.8)
        ax.axvline(median(inter_batch), color='black', linestyle='--',
                   label=f'Median: {median(inter_batch):.0f}s')
        ax.set_xlabel('Seconds between fill events')
        ax.set_ylabel('# gaps')
        ax.set_title('Time Between Fill Events')
        ax.legend()

    ax = axes[1, 1]
    clipped = [min(s, 100) for s in fill_sizes]
    ax.hist(clipped, bins=80, color='purple', edgecolor='white', alpha=0.8)
    ax.axvline(median(fill_sizes), color='black', linestyle='--',
               label=f'Median: {median(fill_sizes):.1f}')
    ax.set_xlabel('Fill size (shares)')
    ax.set_ylabel('# fills')
    ax.set_title(f'Fill Size Distribution (n={len(fill_sizes):,})')
    ax.legend()

    plt.tight_layout()
    path = os.path.join(OUTDIR, '03_batching.png')
    plt.savefig(path, dpi=150)
    plt.close()
    print(f"  Saved: {path}")


# ============================================================================
# PLOT 4: REGIME ANALYSIS
# ============================================================================

def plot_regime_analysis(by_window, prices):
    print("\nPlot 4: Regime analysis...")
    fig, axes = plt.subplots(2, 2, figsize=(16, 12))

    window_stats = []
    slugs = sorted(set(by_window.keys()) & set(prices.keys()))

    for slug in slugs:
        trades = by_window[slug]
        p = prices[slug]
        outcome = get_outcome(p)
        if outcome is None:
            continue

        start_yes, _ = get_price_at(p, p['ts'][0])
        end_yes, _ = get_price_at(p, p['ts'][-1])
        if start_yes is None or end_yes is None:
            continue
        price_move = end_yes - start_yes

        up_cost = sum(t['size'] * t['price'] for t in trades if t['side'] == 'up')
        dn_cost = sum(t['size'] * t['price'] for t in trades if t['side'] == 'down')
        up_sh = sum(t['size'] for t in trades if t['side'] == 'up')
        dn_sh = sum(t['size'] for t in trades if t['side'] == 'down')
        total_cost = up_cost + dn_cost

        if up_sh == 0 or dn_sh == 0:
            continue

        combined = (up_cost / up_sh) + (dn_cost / dn_sh)
        payout = up_sh if outcome == 'UP' else dn_sh
        pnl = payout - total_cost
        final_imb = abs(up_sh - dn_sh) / (up_sh + dn_sh)

        if abs(price_move) < 0.05:
            regime = 'Ranging'
        elif price_move > 0:
            regime = 'Trending UP'
        else:
            regime = 'Trending DN'

        window_stats.append({
            'regime': regime, 'price_move': price_move,
            'combined': combined, 'pnl': pnl,
            'final_imb': final_imb, 'win': 1 if pnl > 0 else 0,
        })

    regimes = defaultdict(list)
    for w in window_stats:
        regimes[w['regime']].append(w)

    regime_names = ['Trending DN', 'Ranging', 'Trending UP']
    colors = ['tomato', 'steelblue', 'green']

    ax = axes[0, 0]
    for i, regime in enumerate(regime_names):
        ws = regimes.get(regime, [])
        if ws:
            bp = ax.boxplot([[w['combined'] for w in ws]], positions=[i],
                           widths=0.6, patch_artist=True, showfliers=False)
            bp['boxes'][0].set_facecolor(colors[i])
            bp['boxes'][0].set_alpha(0.7)
    ax.set_xticks(range(len(regime_names)))
    ax.set_xticklabels(regime_names)
    ax.axhline(1.0, color='red', linestyle='--', alpha=0.5, label='Breakeven')
    ax.set_ylabel('Combined cost per pair')
    ax.set_title('Pair Cost by Market Regime')
    ax.legend()

    ax = axes[1, 0]
    move_buckets = defaultdict(list)
    for w in window_stats:
        bucket = round(w['price_move'] * 10) / 10
        bucket = max(-0.4, min(0.4, bucket))
        move_buckets[bucket].append(w['win'])
    buckets_sorted = sorted(move_buckets.keys())
    wrs = [mean(move_buckets[b]) * 100 for b in buckets_sorted]
    bar_colors = ['tomato' if b < -0.05 else 'green' if b > 0.05 else 'steelblue' for b in buckets_sorted]
    ax.bar(buckets_sorted, wrs, width=0.08, color=bar_colors, alpha=0.8)
    ax.axhline(50, color='gray', linestyle='--', alpha=0.5)
    ax.set_xlabel('Window price move')
    ax.set_ylabel('Win rate (%)')
    ax.set_title('Win Rate by Price Move Direction')

    ax = axes[0, 1]
    moves = [w['price_move'] for w in window_stats]
    pnls = [w['pnl'] for w in window_stats]
    colors_scatter = ['green' if w['win'] else 'red' for w in window_stats]
    ax.scatter(moves, pnls, c=colors_scatter, alpha=0.1, s=5)
    ax.axhline(0, color='gray', linestyle='--')
    ax.axvline(0, color='gray', linestyle='--')
    ax.set_xlabel('Price move')
    ax.set_ylabel('Window P&L ($)')
    ax.set_title('P&L vs Price Move')

    ax = axes[1, 1]
    for i, regime in enumerate(regime_names):
        ws = regimes.get(regime, [])
        if ws:
            bp = ax.boxplot([[w['final_imb'] for w in ws]], positions=[i],
                           widths=0.6, patch_artist=True, showfliers=False)
            bp['boxes'][0].set_facecolor(colors[i])
            bp['boxes'][0].set_alpha(0.7)
    ax.set_xticks(range(len(regime_names)))
    ax.set_xticklabels(regime_names)
    ax.set_ylabel('Final imbalance (|UP-DN|/total)')
    ax.set_title('Final Inventory Imbalance by Regime')

    plt.tight_layout()
    path = os.path.join(OUTDIR, '04_regime_analysis.png')
    plt.savefig(path, dpi=150)
    plt.close()
    print(f"  Saved: {path}")


# ============================================================================
# PLOT 5: PAIR COST & P&L DISTRIBUTIONS
# ============================================================================

def plot_pair_cost_pnl(by_window, prices):
    print("\nPlot 5: Pair cost & P&L...")
    fig, axes = plt.subplots(2, 2, figsize=(16, 12))

    combined_costs = []
    pnls = []
    volumes = []

    slugs = sorted(set(by_window.keys()) & set(prices.keys()))
    for slug in slugs:
        trades = by_window[slug]
        p = prices[slug]
        outcome = get_outcome(p)
        if outcome is None:
            continue

        up_cost = sum(t['size'] * t['price'] for t in trades if t['side'] == 'up')
        dn_cost = sum(t['size'] * t['price'] for t in trades if t['side'] == 'down')
        up_sh = sum(t['size'] for t in trades if t['side'] == 'up')
        dn_sh = sum(t['size'] for t in trades if t['side'] == 'down')

        if up_sh == 0 or dn_sh == 0:
            continue

        combined = (up_cost / up_sh) + (dn_cost / dn_sh)
        payout = up_sh if outcome == 'UP' else dn_sh
        pnl = payout - (up_cost + dn_cost)

        combined_costs.append(combined)
        pnls.append(pnl)
        volumes.append(up_sh + dn_sh)

    ax = axes[0, 0]
    ax.hist(combined_costs, bins=80, range=(0.90, 1.10), color='steelblue',
            edgecolor='white', alpha=0.8)
    ax.axvline(1.0, color='red', linestyle='--', linewidth=2, label='Breakeven')
    ax.axvline(median(combined_costs), color='black', linestyle='--',
               label=f'Median: ${median(combined_costs):.4f}')
    ax.set_xlabel('Combined cost per pair (UP_avg + DN_avg)')
    ax.set_ylabel('# windows')
    ax.set_title('Combined Pair Cost Distribution')
    ax.legend()

    ax = axes[0, 1]
    clipped_pnl = [max(-200, min(200, p)) for p in pnls]
    ax.hist(clipped_pnl, bins=80, color='green', edgecolor='white', alpha=0.8)
    ax.axvline(0, color='red', linestyle='--', linewidth=2)
    ax.axvline(median(pnls), color='black', linestyle='--',
               label=f'Median: ${median(pnls):.2f}')
    ax.set_xlabel('Window P&L ($)')
    ax.set_ylabel('# windows')
    ax.set_title(f'P&L Distribution (total: ${sum(pnls):,.0f})')
    ax.legend()

    ax = axes[1, 0]
    ax.scatter(volumes, combined_costs, alpha=0.15, s=5, color='steelblue')
    ax.axhline(1.0, color='red', linestyle='--')
    ax.set_xlabel('Total shares traded')
    ax.set_ylabel('Combined cost')
    ax.set_title('Pair Cost vs Volume')
    ax.set_ylim(0.90, 1.10)

    ax = axes[1, 1]
    cum_pnl = np.cumsum(pnls)
    ax.plot(cum_pnl, color='green', linewidth=1)
    ax.fill_between(range(len(cum_pnl)), cum_pnl, alpha=0.2, color='green')
    ax.set_xlabel('Window #')
    ax.set_ylabel('Cumulative P&L ($)')
    ax.set_title(f'Cumulative P&L (n={len(pnls)} windows)')
    ax.axhline(0, color='gray', linestyle='--')

    plt.tight_layout()
    path = os.path.join(OUTDIR, '05_pair_cost_pnl.png')
    plt.savefig(path, dpi=150)
    plt.close()
    print(f"  Saved: {path}")


# ============================================================================
# PLOT 6: DETAILED WINDOW EXAMPLES
# ============================================================================

def plot_example_windows(by_window, prices, n=6):
    """Show 6 example windows: 2 ranging, 2 trending up, 2 trending down."""
    print("\nPlot 6: Example windows...")

    slugs = sorted(set(by_window.keys()) & set(prices.keys()))
    categorized = {'Ranging': [], 'Trending UP': [], 'Trending DN': []}

    for slug in slugs:
        p = prices[slug]
        outcome = get_outcome(p)
        if outcome is None or len(p['yes']) < 20:
            continue
        move = p['yes'][-1] - p['yes'][0]
        if len(by_window[slug]) < 100:
            continue
        if abs(move) < 0.05:
            categorized['Ranging'].append(slug)
        elif move > 0.15:
            categorized['Trending UP'].append(slug)
        elif move < -0.15:
            categorized['Trending DN'].append(slug)

    fig, axes = plt.subplots(3, 2, figsize=(18, 18))
    np.random.seed(99)

    for row, (regime, slug_list) in enumerate(categorized.items()):
        if len(slug_list) < 2:
            continue
        samples = np.random.choice(slug_list, min(2, len(slug_list)), replace=False)

        for col, slug in enumerate(samples):
            ax = axes[row, col]
            trades = by_window[slug]
            p = prices[slug]
            window_start = int(slug.split('-')[-1])
            outcome = get_outcome(p)

            times_p = [(t - p['ts'][0]) / 900 for t in p['ts']]
            ax2 = ax.twinx()
            ax2.plot(times_p, p['yes'], color='gray', alpha=0.5, linewidth=1, label='YES price')
            ax2.set_ylabel('YES price', color='gray')
            ax2.set_ylim(0, 1)

            up_cum, dn_cum, fill_times = [], [], []
            up_total, dn_total = 0, 0
            for t in trades:
                if t['side'] == 'up':
                    up_total += t['size']
                else:
                    dn_total += t['size']
                pct = (t['ts'] - window_start) / 900.0
                up_cum.append(up_total)
                dn_cum.append(dn_total)
                fill_times.append(pct)

            ax.plot(fill_times, up_cum, color='blue', linewidth=1.5, label='UP shares')
            ax.plot(fill_times, dn_cum, color='red', linewidth=1.5, label='DN shares')
            ax.set_xlabel('% window elapsed')
            ax.set_ylabel('Cumulative shares')

            up_cost = sum(t['size'] * t['price'] for t in trades if t['side'] == 'up')
            dn_cost = sum(t['size'] * t['price'] for t in trades if t['side'] == 'down')
            combined = (up_cost / up_total + dn_cost / dn_total) if up_total > 0 and dn_total > 0 else 0
            payout = up_total if outcome == 'UP' else dn_total
            pnl = payout - (up_cost + dn_cost)

            ax.set_title(f'{regime} | {outcome} | combined=${combined:.3f} | P&L=${pnl:.0f}',
                        fontsize=10)
            ax.legend(loc='upper left', fontsize=8)
            ax.set_xlim(0, 1)

    plt.tight_layout()
    path = os.path.join(OUTDIR, '06_example_windows.png')
    plt.savefig(path, dpi=150)
    plt.close()
    print(f"  Saved: {path}")


# ============================================================================
# PLOT 7: CROSSING BEHAVIOR DEEP DIVE
# ============================================================================

def plot_crossing_deep_dive(by_window, prices):
    print("\nPlot 7: Crossing behavior deep dive...")
    fig, axes = plt.subplots(2, 2, figsize=(16, 12))

    window_crossing = []
    slugs = sorted(set(by_window.keys()) & set(prices.keys()))

    for slug in slugs:
        trades = by_window[slug]
        p = prices[slug]
        outcome = get_outcome(p)
        if outcome is None:
            continue

        up_sh, dn_sh = 0, 0
        n_agg, n_pass = 0, 0
        agg_edges = []

        for t in trades:
            yes_p, no_p = get_price_at(p, t['ts'])
            if yes_p is not None:
                mid = yes_p if t['side'] == 'up' else no_p
                edge = mid - t['price']
                if edge <= 0:
                    n_agg += 1
                    agg_edges.append(-edge)
                else:
                    n_pass += 1
            if t['side'] == 'up': up_sh += t['size']
            else: dn_sh += t['size']

        total_fills = n_agg + n_pass
        if total_fills == 0:
            continue

        up_cost = sum(t['size'] * t['price'] for t in trades if t['side'] == 'up')
        dn_cost = sum(t['size'] * t['price'] for t in trades if t['side'] == 'down')
        combined = (up_cost / up_sh + dn_cost / dn_sh) if up_sh > 0 and dn_sh > 0 else None
        payout = up_sh if outcome == 'UP' else dn_sh
        pnl = payout - (up_cost + dn_cost)

        window_crossing.append({
            'agg_pct': n_agg / total_fills,
            'avg_cross_depth': mean(agg_edges) if agg_edges else 0,
            'combined': combined, 'pnl': pnl,
            'win': 1 if pnl > 0 else 0,
            'final_imb': abs(up_sh - dn_sh) / (up_sh + dn_sh),
        })

    ax = axes[0, 0]
    agg_pcts = [w['agg_pct'] * 100 for w in window_crossing]
    ax.hist(agg_pcts, bins=50, color='tomato', edgecolor='white', alpha=0.8)
    ax.axvline(median(agg_pcts), color='black', linestyle='--',
               label=f'Median: {median(agg_pcts):.1f}%')
    ax.set_xlabel('Aggressive fill %')
    ax.set_ylabel('# windows')
    ax.set_title('Aggression Rate Per Window')
    ax.legend()

    ax = axes[0, 1]
    agg_buckets = defaultdict(list)
    for w in window_crossing:
        bucket = round(w['agg_pct'] * 10) / 10
        agg_buckets[bucket].append(w['win'])
    buckets_sorted = sorted(agg_buckets.keys())
    wrs = [mean(agg_buckets[b]) * 100 for b in buckets_sorted]
    ax.bar([b * 100 for b in buckets_sorted], wrs, width=8, color='steelblue', alpha=0.8)
    ax.axhline(mean(w['win'] for w in window_crossing) * 100, color='red', linestyle='--',
               label=f'Overall: {mean(w["win"] for w in window_crossing) * 100:.1f}%')
    ax.set_xlabel('Aggressive fill %')
    ax.set_ylabel('Win rate (%)')
    ax.set_title('Win Rate by Aggression Level')
    ax.legend()

    ax = axes[1, 0]
    depths = [w['avg_cross_depth'] * 100 for w in window_crossing if w['combined'] is not None]
    costs = [w['combined'] for w in window_crossing if w['combined'] is not None]
    ax.scatter(depths, costs, alpha=0.15, s=5, color='tomato')
    ax.axhline(1.0, color='gray', linestyle='--')
    ax.set_xlabel('Avg crossing depth (cents)')
    ax.set_ylabel('Combined cost')
    ax.set_title('Crossing Depth vs Pair Cost')
    ax.set_ylim(0.90, 1.10)

    ax = axes[1, 1]
    agg = [w['agg_pct'] * 100 for w in window_crossing]
    imb = [w['final_imb'] * 100 for w in window_crossing]
    ax.scatter(agg, imb, alpha=0.1, s=5, color='purple')
    ax.set_xlabel('Aggressive fill %')
    ax.set_ylabel('Final imbalance (%)')
    ax.set_title('Does More Aggression Reduce Imbalance?')

    plt.tight_layout()
    path = os.path.join(OUTDIR, '07_crossing_deep_dive.png')
    plt.savefig(path, dpi=150)
    plt.close()
    print(f"  Saved: {path}")


# ============================================================================
# MAIN
# ============================================================================

def main():
    by_window = load_trades()
    prices = load_prices()

    plot_inventory_trajectories(by_window, prices)
    plot_fill_vs_mid(by_window, prices)
    plot_batching(by_window)
    plot_regime_analysis(by_window, prices)
    plot_pair_cost_pnl(by_window, prices)
    plot_example_windows(by_window, prices)
    plot_crossing_deep_dive(by_window, prices)

    print(f"\n{'=' * 70}")
    print(f"All plots saved to: {OUTDIR}/")
    print(f"{'=' * 70}")


if __name__ == '__main__':
    main()
